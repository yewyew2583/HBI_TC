<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_DebugStationSeq" Id="{09f9be3c-5add-4051-b26d-1258202fe318}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DebugStationSeq EXTENDS Tc3_HBI_System.FB_Basic
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	nI : UINT;
	
	stDebugStationBIO		:ST_DebugStation_BIO;
	stDebugStationDIO		: ST_DebugStation_DIO;
	stDebugStationVIO		: ST_DebugStation_VIO;
	stDbColVIO				: ST_DebugColumnDIO;
	
	stDbStnParam 			: ST_DebugStationSeqParam;
	fbBD_ipBdoor 			: Tc3_HBI_Utilities.FB_BackDoor_Digital;
	
	btest					: BOOL;

	DIFUOn_TstPwr			: R_TRIG;
	DIFUOn_AP240Pwr			: R_TRIG;
	DIFUSet_bChkTstOn		: R_TRIG; 	//
	DIFUAPPresent			: R_TRIG;
	DIFDAPPresent			: F_TRIG;
	DIFUSet_bChkAP240On		: R_TRIG; 	//
	
	FB_opDBStnAP240ACPwrEnable					: DFB_Cylinder;
	DUT_opDBStnAP240ACPwrEnable					: DUT_Cylinder;
	Permissive_opDBStnAP240ACPwrEnable			: WORD;
	Shutdown_opDBStnAP240ACPwrEnable			: WORD;
	Reset_opDBStnAP240ACPwrEnable				: R_TRIG;
	Precondition_opDBStnAP240ACPwrEnable		: BOOL;
	_Alarm										: BOOL;
	
	FB_opDBStn24VPowerEnable					: DFB_Cylinder;
	DUT_opDBStn24VPowerEnable					: DUT_Cylinder;
	Reset_opDBStn24VPowerEnable					: R_TRIG;
	Precondition_opDBStn24VPowerEnable			: BOOL;
	
	FB_opDBStnPCWValve							: DFB_Cylinder;
	DUT_opDBStnPCWValve							: DUT_Cylinder;
	Reset_opDBStnPCWValve						: R_TRIG;
	Precondition_opDBStnPCWValve				: BOOL;
	
	tstOnCheckTim				: TON;		//delay to check TesterOnFeedback
	ap240OnCheckTim				: TON;		//delay to check AP240OnFeedback
	tstPresentTim				: TON;		//delay to On Tester Air Valve after Tester Present
	apPresentTimer				: TON;
	
	isLeakage:BOOL;
	isGroundFault:BOOL;
	
		// Common var 
	bPause 						: BOOL; //Sequence pause
	bBypassSingleMove 			: BOOL	:= TRUE;
	bStep 						: BOOL;
	rtStep						: R_TRIG;
	rtStepCase					: R_TRIG;
	rtError						: R_TRIG;
	iStkSeqCase 				: INT;
	iSeqStep					: INT;
	iSysRsetSeqStep				: INT;
	arrSeqStep					: ARRAY [0..50] OF E_SeqSts; 			// seq
	arrSysRsetSeqStep			: ARRAY [0..50] OF E_SeqSts; 	//Sys Rset seq
	
	sMessage : STRING;
	bErrClear: BOOL;
	bStepDone: BOOL;
	bSafeExecute: BOOL;
	iStkSingStackUp:INT;
	iLibrySts : ARRAY [1..20] OF UDINT;
	
	
	
	tAPACPwrDelayToComplete		:TON;  	//AP240ACPowerOnOff
	tAPACPwrDelayToAutoComplete	:TON;	//AP240ACPowerAuto
	
	
	timInc:TON;
	bTIISenSimArray:ARRAY[1..NO_OF_TII_SENSOR] OF BOOL;
	TimTemp:TON;
	
	//TiiInterlock
	itl_opDBStn24VPowerEnable			: BOOL;
	itl_opDBStnPCWValve					: BOOL;
	itl_opDBStnAP240ACPwrEnable			: BOOL;
	itl_opDBStnBypassAPAirSupplySol		: BOOL;
	itl_opDBStnAPSafeToEngage			: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
]]></ST>
    </Implementation>
    <Method Name="Conversion" Id="{a226b9d3-12c7-467d-870e-e671e401b57e}">
      <Declaration><![CDATA[METHOD Conversion : BOOL
VAR_INPUT
	isSimulation : BOOL;
	//dIO:ST_DebugStation_DIO;
END_VAR
VAR		
	tempSimIpt:LREAL;
END_VAR
VAR_IN_OUT
	//vIO:ST_DebugStation_VIO;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF isSimulation THEN
	//GetRand(Seed:=0,Num=>tempSimIpt);
	//stDebugStationDIO.simDBStnTstAirLeakFlowSensor := tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnTstAirLeakFlowSensor(Mn:=spDBStnTstAirLeakFlowSensor.iMn, mx:=spDBStnTstAirLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnTstAirLeakFlowSensor);
	//stDebugStationDIO.simDBStnTstAirLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnTstAirLeakFlowSensor));							
	stDebugStationDIO.ipDBStnTstAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnTstAirLeakFlowSensor.iMn, 
																	iMx:= spDBStnTstAirLeakFlowSensor.iMx, 
																	oMn:= spDBStnTstAirLeakFlowSensor.oMn, 
																	oMx:= spDBStnTstAirLeakFlowSensor.oMx, 
																	ofs:= spDBStnTstAirLeakFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnTstAirLeakFlowSensor) , 
																	b  := spDBStnTstAirLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.ipDBStnAPAirLeakFlowSensor :=tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnAPAirLeakFlowSensor(Mn:=spDBStnAPAirLeakFlowSensor.iMn, mx:=spDBStnAPAirLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnAPAirLeakFlowSensor);
	//stDebugStationDIO.ipDBStnAPAirLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnTstAirLeakFlowSensor));															
	stDebugStationDIO.ipDBStnAPAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnAPAirLeakFlowSensor.iMn, 
																	iMx:= spDBStnAPAirLeakFlowSensor.iMx, 
																	oMn:= spDBStnAPAirLeakFlowSensor.oMn, 
																	oMx:= spDBStnAPAirLeakFlowSensor.oMx, 
																	ofs:= spDBStnAPAirLeakFlowSensor.ofs, 
																	val:=  LREAL_TO_INT(stDebugStationDIO.simDBStnAPAirLeakFlowSensor) , 
																	b  := spDBStnAPAirLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.simDBStnPCWLeakFlowSensor := tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnPCWLeakFlowSensor(Mn:=spDBStnPCWLeakFlowSensor.iMn, mx:=spDBStnPCWLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnPCWLeakFlowSensor);
	//stDebugStationDIO.simDBStnPCWLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnPCWLeakFlowSensor));
	stDebugStationDIO.ipDBStnPCWLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLeakFlowSensor.iMn, 
																	iMx:= spDBStnPCWLeakFlowSensor.iMx, 
																	oMn:= spDBStnPCWLeakFlowSensor.oMn, 
																	oMx:= spDBStnPCWLeakFlowSensor.oMx, 
																	ofs:= spDBStnPCWLeakFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnPCWLeakFlowSensor) , 
																	b  := spDBStnPCWLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.simDBStnPCWLowFlowSensor :=tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnPCWLowFlowSensor(Mn:=spDBStnPCWLowFlowSensor.iMn, mx:=spDBStnPCWLowFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnPCWLowFlowSensor);
	//stDebugStationDIO.simDBStnPCWLowFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnPCWLowFlowSensor));
	stDebugStationDIO.ipDBStnPCWLowFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLowFlowSensor.iMn, 
																	iMx:= spDBStnPCWLowFlowSensor.iMx, 
																	oMn:= spDBStnPCWLowFlowSensor.oMn, 
																	oMx:= spDBStnPCWLowFlowSensor.oMx, 
																	ofs:= spDBStnPCWLowFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnPCWLowFlowSensor) , 
																	b  := spDBStnPCWLowFlowSensor.b);
	IF NOT bDebugStation THEN
		stDebugStationDIO.ipDBStnTstAirLeakFlowSensor 	:=
		stDebugStationDIO.ipDBStnAPAirLeakFlowSensor 	:=
		stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=
		stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
	ELSE
		IF stDebugStationDIO.opDBStnPCWFlowBypassValve THEN
			stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=
			stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
		ELSE
			IF NOT stDebugStationDIO.opDBStnLeakFlowPCWValve THEN
				stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=0;
			END_IF
			IF NOT stDebugStationDIO.opDBStnLowFlowPCWValve THEN
				stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
			END_IF
		END_IF
	END_IF	
	
ELSE
	stDebugStationDIO.ipDBStnTstAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnTstAirLeakFlowSensor.iMn, 
																iMx:= spDBStnTstAirLeakFlowSensor.iMx, 
																oMn:= spDBStnTstAirLeakFlowSensor.oMn, 
																oMx:= spDBStnTstAirLeakFlowSensor.oMx, 
																ofs:= spDBStnTstAirLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnTstAirLeakFlowSensor , 
																b  := spDBStnTstAirLeakFlowSensor.b);
																
	stDebugStationDIO.ipDBStnAPAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnAPAirLeakFlowSensor.iMn, 
																iMx:= spDBStnAPAirLeakFlowSensor.iMx, 
																oMn:= spDBStnAPAirLeakFlowSensor.oMn, 
																oMx:= spDBStnAPAirLeakFlowSensor.oMx, 
																ofs:= spDBStnAPAirLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnAPAirLeakFlowSensor , 
																b  := spDBStnAPAirLeakFlowSensor.b);

	stDebugStationDIO.ipDBStnPCWLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLeakFlowSensor.iMn, 
																iMx:= spDBStnPCWLeakFlowSensor.iMx, 
																oMn:= spDBStnPCWLeakFlowSensor.oMn, 
																oMx:= spDBStnPCWLeakFlowSensor.oMx, 
																ofs:= spDBStnPCWLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnPCWLeakFlowSensor , 
																b  := spDBStnPCWLeakFlowSensor.b);

	stDebugStationDIO.ipDBStnPCWLowFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLowFlowSensor.iMn, 
																iMx:= spDBStnPCWLowFlowSensor.iMx, 
																oMn:= spDBStnPCWLowFlowSensor.oMn, 
																oMx:= spDBStnPCWLowFlowSensor.oMx, 
																ofs:= spDBStnPCWLowFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnPCWLowFlowSensor , 
																b  := spDBStnPCWLowFlowSensor.b);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="INC" Id="{898b9e45-f951-4f57-91d5-d720dcc3f9a3}">
      <Declaration><![CDATA[METHOD INC : UDINT
VAR_INPUT
	IN:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*IF timInc.Q THEN
	IF IN >= 32768 THEN
		INC := 0; 
	ELSE
		INC := IN+500; 
	END_IF
	timInc(IN:=FALSE);
ELSE
	timInc(IN:=TRUE,PT:=T#500MS);
END_IF
*)

	IF IN >= 32768 THEN
		INC := 0; 
	ELSE
		INC := IN+5; 
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AP240Power" Id="{8b504b38-c8b9-4f13-804b-f71cac2517bc}">
      <Declaration><![CDATA[METHOD M_AP240Power : UDINT
VAR_INPUT
END_VAR
VAR 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// new implementation motor
PermSD();

IF DewPoint_Abort OR OFA6Bar_Abort THEN
	_Alarm		:= TRUE;
ELSIF (NOT ALM_DCCOL.AlarmID[E_DCFACAlarm.eCriticalCondensationAlarm]) AND (NOT ALM_DCCOL.AlarmID[E_DCFACAlarm.e6BarLowOFAAirPressureAlarm]) THEN
	_Alarm		:= FALSE;
END_IF

Precondition_opDBStnAP240ACPwrEnable	:= (stDebugStationVIO.ipDBStnAPPresentSensor AND (NOT itl_opDBStnAP240ACPwrEnable) AND (NOT _Alarm))
											AND stDebugStationVIO.bAP240ACPowerOnOff;

Reset_opDBStnAP240ACPwrEnable(CLK:= precondition_opDBStnAP240ACPwrEnable);

DUT_opDBStnAP240ACPwrEnable.AutInp		:= Precondition_opDBStnAP240ACPwrEnable;
DUT_opDBStnAP240ACPwrEnable.Reset		:= Reset_opDBStnAP240ACPwrEnable.Q;
DUT_opDBStnAP240ACPwrEnable.Travel_Time	:= 2;
											
											
FB_opDBStnAP240ACPwrEnable(
	Sec_P		:= Sec_P, 
	ID		:= 'DebugCart AP240Power', 
	Simulate		:= DUT_opDBStnAP240ACPwrEnable.Simulate, 
	Permissive		:= Permissive_opDBStnAP240ACPwrEnable, 
	ShutDown		:= Shutdown_opDBStnAP240ACPwrEnable, 
	AutoInp		:= DUT_opDBStnAP240ACPwrEnable.AutInp, 
	Command		:= DUT_opDBStnAP240ACPwrEnable.CMD, 
	IExtend		:= stDebugStationVIO.ipDBStnAPPowerOn, 
	IRetract		:= (NOT stDebugStationVIO.ipDBStnAPPowerOn), 
	Travel_Time		:= DUT_opDBStnAP240ACPwrEnable.Travel_Time, 
	SetOutput_Pulse		:= FALSE, 
	FailedHoldLast		:= FALSE,
	OExtend		=> stDebugStationVIO.opDBStnAP240ACPwrEnable, 
	ORetract		=> , 
	DUT		:= DUT_opDBStnAP240ACPwrEnable);
//</APPowerOn>

GVL_DUT_DC_AP240ACPower		:= DUT_opDBStnAP240ACPwrEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InputBackDoor" Id="{54fd951e-6cc1-4e59-88f8-e89efea4a997}">
      <Declaration><![CDATA[METHOD M_InputBackDoor : UDINT
VAR
	i			: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stDebugStationVIO.ipDBStnAPPresentSensor		:= fbBD_ipBdoor.M_bBackDoorCtrl(
																	bProductionMode			:= bProductionMode, 
	                                            					bActual					:= stDebugStationDIO.ipDBStnAPPresentSensor, 
	                                            					bSimu					:= TRUE , 
	                                            					iBackDoor				:= stDebugStationBIO.ipDBStnAPPresentSensor );
																	
stDebugStationVIO.ipDBStnAPPowerOn		:= fbBD_ipBdoor.M_bBackDoorCtrl(
															bProductionMode					:= bProductionMode,
	                                            			bActual							:= stDebugStationDIO.ipDBStnAPPowerOn, 
	                                            			bSimu							:= TRUE , 
	                                           				iBackDoor						:= stDebugStationBIO.ipDBStnAPPowerOn );													

stDebugStationVIO.ipDBStnAPReady		:= fbBD_ipBdoor.M_bBackDoorCtrl(
															bProductionMode					:= bProductionMode,
	                                            			bActual							:= stDebugStationDIO.ipDBStnAPReady , 
	                                            			bSimu							:= TRUE , 
	                                           				iBackDoor						:= stDebugStationBIO.ipDBStnAPReady );	


stDebugStationVIO.ipDBStnHandlerSafeToEnterPLC		:= fbBD_ipBdoor.M_bBackDoorCtrl(
																		bProductionMode			:= bProductionMode , 
	                                            						bActual					:= stDebugStationDIO.ipDBStnHandlerSafeToEnterPLC , 
	                                            						bSimu					:= TRUE , 
	                                            						iBackDoor				:= stDebugStationBIO.ipDBStnHandlerSafeToEnterPLC );	

stDebugStationVIO.ipDBStnHandlerSafeToEnterHwr		:= fbBD_ipBdoor.M_bBackDoorCtrl(
																		bProductionMode			:= bProductionMode , 
	                                            						bActual					:= stDebugStationDIO.ipDBStnHandlerSafeToEnterHwr ,
	                                            						bSimu					:= TRUE,
	                                            						iBackDoor				:= stDebugStationBIO.ipDBStnHandlerSafeToEnterHwr );

stDebugStationVIO.ipDBStnCellGroundFault		:= fbBD_ipBdoor.M_bBackDoorCtrl(
																	bProductionMode				:= bProductionMode , 
	                                            					bActual						:= stDebugStationDIO.ipDBStnCellGroundFault , 
	                                            					bSimu						:= FALSE , 
	                                            					iBackDoor					:= stDebugStationBIO.ipDBStnCellGroundFault );
																	
stDebugStationVIO.ipDBStnCellFluidLeakage1		:= NOT fbBD_ipBdoor.M_bBackDoorCtrl(
																		bProductionMode			:= bProductionMode, 
	                                            						bActual					:= stDebugStationDIO.ipDBStnCellFluidLeakage1 , 
	                                            						bSimu					:= TRUE , 
	                                            						iBackDoor				:= stDebugStationBIO.ipDBStnCellFluidLeakage1 );
				
stDebugStationVIO.ipDBStnCellFluidLeakage2		:= NOT fbBD_ipBdoor.M_bBackDoorCtrl(
																		bProductionMode			:= bProductionMode, 
	                                            						bActual					:= stDebugStationDIO.ipDBStnCellFluidLeakage2 , 
	                                            						bSimu					:= TRUE , 
	                                            						iBackDoor				:= stDebugStationBIO.ipDBStnCellFluidLeakage2 );


stDebugStationVIO.ipDBStnPurgeButton			:= fbBD_ipBdoor.M_bBackDoorCtrl(
																	bProductionMode				:= bProductionMode, 
	                                            					bActual						:= stDebugStationDIO.ipDBStnPurgeButton, 
	                                            					bSimu						:= FALSE, 
	                                            					iBackDoor					:= stDebugStationBIO.ipDBStnPurgeButton);
																				
																				
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// Simulation Input Mapping for VISU ////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IF NOT bProductionMode THEN
	stDebugStationDIO.ipDBStnAPPresentSensor			:= stDebugStationVIO.ipDBStnAPPresentSensor;
	stDebugStationDIO.ipDBStnAPPowerOn					:= stDebugStationVIO.ipDBStnAPPowerOn;
	stDebugStationDIO.ipDBStnAPReady					:= stDebugStationVIO.ipDBStnAPReady;
	stDebugStationDIO.ipDBStnHandlerSafeToEnterHwr		:= stDebugStationVIO.ipDBStnHandlerSafeToEnterHwr;
	stDebugStationDIO.ipDBStnHandlerSafeToEnterPLC		:= stDebugStationVIO.ipDBStnHandlerSafeToEnterPLC;
	stDebugStationDIO.ipDBStnCellGroundFault			:= stDebugStationVIO.ipDBStnCellGroundFault;
	stDebugStationDIO.ipDBStnCellFluidLeakage1			:= NOT stDebugStationVIO.ipDBStnCellFluidLeakage1;
	stDebugStationDIO.ipDBStnCellFluidLeakage2			:= NOT stDebugStationVIO.ipDBStnCellFluidLeakage2;
	stDebugStationDIO.ipDBStnPurgeButton				:= stDebugStationVIO.ipDBStnPurgeButton;
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InterlockTII" Id="{b5e494f2-cd73-4b26-9c75-18bc5b6b4f42}">
      <Declaration><![CDATA[METHOD M_InterlockTII : UDINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[itl_opDBStn24VPowerEnable	:=		ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage1		]	OR	
									ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage2		]	OR	
									ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellGroundFault 	   	]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm		]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm	]	OR 	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm	]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakage2Alarm		];
								
itl_opDBStnPCWValve			:=		ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage1		] 	OR	
									ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage2		] 	OR	
									ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellGroundFault 	   	]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm		]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm	]	OR 	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm	]	OR	
									ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakage2Alarm		];
								
itl_opDBStnAP240ACPwrEnable		:=		ALMTC.Level[1].ALarmID[E_TIIAlarm.ipAPReady					]	OR	
										ALMTC.Level[1].AlarmID[E_TIIAlarm.ipAPPowerOn				]	OR 	
										ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage1		]	OR	
										ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage2		]	OR	
										ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellGroundFault 	   	]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm		]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm	]	OR 	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm	]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakage2Alarm		];
									
itl_opDBStnBypassAPAirSupplySol	:=		ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage1			]	OR	
										ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellFluidLeakage2			]	OR	
										ALMTC.Level[1].ALarmID[E_TIIAlarm.ipCellGroundFault 	   		]	OR	
										ALMTC.Level[1].AlarmID[E_TIIAlarm.ipAPReady						]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm			]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm		]	OR 	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm		]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakage2Alarm			];
									
itl_opDBStnAPSafeToEngage		:=	 	ALMTC.Level[1].AlarmID[E_TIIAlarm.ipCellGroundFault 	   		]	OR	
										ALMTC.Level[1].AlarmID[E_TIIAlarm.ipCellFluidLeakage1 	   		]	OR	
										ALMTC.Level[1].AlarmID[E_TIIAlarm.ipCellFluidLeakage2 	   		]	OR	
										//ALM_DCCOL.AlarmID[E_DCFACAlarm.eCriticalCondensationAlarm		]	OR	
										//ALM_DCCOL.AlarmID[E_DCFACAlarm.e6BarLowOFAAirPressureAlarm		]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm			]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm		]	OR 	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm		]	OR	
										ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakage2Alarm			];			
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IOMapping" Id="{a72e6ef1-5a7c-4aa4-b869-c7c8e540ce38}">
      <Declaration><![CDATA[METHOD M_IOMapping : BOOL
VAR_INPUT
	
END_VAR

VAR
	bSimu:BOOL:=FALSE;
	stMLVIO: INT;
	ipDBStnAPPowerOn: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////	Input Assignment //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
M_InputBackDoor();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////	Looping Outputs //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
M_InterlockTII();		
M_AP240Power();
M_Secondary24VPower();
M_opDbStnPCWValve();

//stDebugStationVIO.opDBStnPCWValve			:= (stDebugStationVIO.ipDBStnAPPresentSensor);
stDebugStationVIO.opDBStnAPSafeToEngage 	:= 	stDebugStationVIO.ipDBStnAPPresentSensor;														

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////	IO Mapping Outputs //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////											
IF NOT stDebugStationVIO.bDiagnosticMode	THEN	
	stDebugStationDIO.opDBStnAP240ACPwrEnable			:= NOT itl_opDBStnAP240ACPwrEnable		AND		stDebugStationVIO.opDBStnAP240ACPwrEnable;			
	stDebugStationDIO.opAP_DIO_1						:= 												stDebugStationVIO.opAP_DIO_1;
	stDebugStationDIO.opAP_DIO_2						:= 												stDebugStationVIO.opAP_DIO_2;
	stDebugStationDIO.opAP_DIO_3						:= 												stDebugStationVIO.opAP_DIO_3;
	stDebugStationDIO.opDBStnPCWValve					:= NOT itl_opDBStnPCWValve				AND		stDebugStationVIO.opDBStnPCWValve;
	stDebugStationDIO.opDBStnPCWFlowBypassValve         := 												stDebugStationVIO.opDBStnPCWFlowBypassValve;
	stDebugStationDIO.opDBStnBypassAPAirSupplySol       := NOT itl_opDBStnBypassAPAirSupplySol	AND		stDebugStationVIO.opDBStnBypassAPAirSupplySol;
	stDebugStationDIO.opDBStn24VPowerEnable             := NOT itl_opDbStn24VPowerEnable 		AND 	stDebugStationVIO.opDBStn24VPowerEnable;
	stDebugStationDIO.opDBStnLeakFlowPCWValve           := 												stDebugStationVIO.opDBStnLeakFlowPCWValve;
	stDebugStationDIO.opDBStnLowFlowPCWValve            := 												stDebugStationVIO.opDBStnLowFlowPCWValve;
	stDebugStationDIO.opDBStnAPSafeToEngage         	:= NOT itl_opDBStnAPSafeToEngage		AND		stDebugStationVIO.opDBStnAPSafeToEngage;
	stDebugStationDIO.opDBStnAPTCCReset                 := 												stDebugStationVIO.opDBStnAPTCCReset;
	stDebugStationDIO.opDBStnMainPCWReturn				:= 												stDebugStationVIO.opDBStnMainPCWReturn;
	stDebugStationDIO.opDBStnPCWSupplyPurge				:= 												stDebugStationVIO.opDBStnPCWSupplyPurge;
	stDebugStationDIO.opCellLTIMValve					:= 												stDebugStationVIO.opCellLTIMValve;
	stDebugStationDIO.opDBStnAlarmLED					:= 												stDebugStationVIO.opDBStnAlarmLED;
	stDebugStationDIO.opDBStnPurgeLED					:= 												stDebugStationVIO.opDBStnPurgeLED;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nCyclic" Id="{7475bd0d-875c-4872-a0ee-0a195890a3a7}">
      <Declaration><![CDATA[METHOD M_nCyclic : UDINT
VAR_INPUT
END_VAR


VAR
	//stTCM: INT;
	stGblParam: INT;
	varTest:bool;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Conversion(isSimulation:=bAnalogIOSim);
M_IOMapping();

rtError(CLK:=_bError, Q=> );
btest					:= TRUE;
		
IF _bReset OR bStepDone OR rtError.Q THEN
	FOR nI:=1 TO 20 DO 
		iLibrySts[1] 	:= 0;
	END_FOR
	bStepDone			:= FALSE; 
END_IF
	
IF _bReset THEN
	IF stDbStnParam.bInitialise THEN
		iSysRsetSeqStep	:= 0;
	ELSE
		iSeqStep		:= 0;
	END_IF
	iStkSeqCase			:= 0;
	bStepDone			:= FALSE;
	sMessage			:= '';
	_bError				:= FALSE;
	_nErrorID			:= 0;
ELSIF bErrClear THEN
	_bError				:= FALSE;
	_nErrorID			:= 0;
	bErrClear			:= FALSE;
END_IF

bPause:=_bReset OR _bError OR bErrClear;
//M_StkSingStackUp state
IF _bError THEN
	iStkSingStackUp		:= 99;
ELSIF _bReset THEN
	iStkSingStackUp		:= 0;
ELSIF iStkSeqCase=E_SeqSts.eDone THEN
	iStkSingStackUp		:= 10;
ELSIF NOT bPause THEN
	iStkSingStackUp		:= 3;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nDPSPowerOnOff" Id="{be69dcd0-a948-487b-8886-639ea27a5501}">
      <Declaration><![CDATA[METHOD M_nDPSPowerOnOff : INT
VAR_INPUT
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_nDPSPowerOnOff					:= iStkSingStackUp;

IF bPause THEN
	RETURN;

ELSIF itl_opDBStnAP240ACPwrEnable THEN  
	M_nDPSPowerOnOff				:= 20;		
	RETURN;
END_IF
IF iSeqStep>0 THEN
	;//Do nothing;
	
ELSIF stDbStnParam.bAP240ACPowerOff 	OR
	  stDbStnParam.bAP240ACPowerOn 		OR
	  stDbStnParam.bAP240ACPowerAuto  	THEN
	arrSeqStep[0]					:= E_SeqSts.eInit;						//Init
	arrSeqStep[1]					:= E_SeqSts.eSanityCheckForAPPwr;		//Sanity check
	arrSeqStep[2]					:= E_SeqSts.eAP240ACPwrOnOff;			//AP240ACPowerOnOff
	arrSeqStep[3]					:= E_SeqSts.eDone;						//Done
	
END_IF


//Sequence start
iStkSeqCase:=arrSeqStep[iSeqStep];

// State machine
CASE iStkSeqCase OF
	E_SeqSts.eInit: //Init
		//TDelay(IN:=FALSE);
		sMessage					:= 'Start Executing';
		bStepDone					:= TRUE;
	
	E_SeqSts.eSanityCheckForAPPwr: 				//Sanity check AP
		sMessage					:= 'CheckTeir2IIAlarm';
		
		tAPACPwrDelayToComplete(IN:=FALSE);
		tAPACPwrDelayToAutoComplete(IN:=FALSE);
		bStepDone					:= TRUE;	
		
	E_SeqSts.eAP240ACPwrOnOff:										// AP240ACPowerOnOff
		tAPACPwrDelayToComplete(IN:=TRUE, PT:=T#2S); 			// origin T#10s
		IF tAPACPwrDelayToComplete.Q THEN
			IF stDbStnParam.bAP240ACPowerOff THEN 			(*0=Off, 1=On, 2=Auto(Off->On) *)
				stDebugStationVIO.bAP240ACPowerOnOff				:= FALSE;//TRUE;
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#0S);	
				sMessage											:= 'AP240AC PowerOff';
			ELSIF stDbStnParam.bAP240ACPowerOn THEN
				stDebugStationVIO.bAP240ACPowerOnOff				:= TRUE;//FALSE;
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#0S);
				sMessage											:= 'AP240AC PowerOn';
			ELSIF  stDbStnParam.bAP240ACPowerAuto THEN
				stDebugStationVIO.bAP240ACPowerOnOff				:=FALSE;//TRUE;
				sMessage											:='AP240AC PowerOff';
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#2S); // origin T#10s
				IF tAPACPwrDelayToAutoComplete.Q THEN
					stDebugStationVIO.bAP240ACPowerOnOff			:=TRUE;//FALSE;	
					sMessage										:='AP240AC PowerOn';
				END_IF
			END_IF
		END_IF
			
		IF tAPACPwrDelayToComplete.Q AND tAPACPwrDelayToAutoComplete.Q THEN
			tAPACPwrDelayToComplete(IN:=FALSE);
			tAPACPwrDelayToAutoComplete(IN:=FALSE);
			bStepDone														:= TRUE;
		END_IF
		
	E_SeqSts.eDone:	// Done
		sMessage							:= 'Done';
		M_nDPSPowerOnOff					:= 10;
END_CASE	

(*IF _nErrorID>0 OR _bError THEN
	_bError:=TRUE;
ELS*)
IF (bStep OR bBypassSingleMove OR iStkSeqCase<=E_SeqSts.eSanityCheck) 
AND iStkSeqCase<E_SeqSts.eDone AND bStepDone THEN
	iSeqStep													:= iSeqStep+1;
END_IF

rtStep(CLK:=bStep AND NOT bBypassSingleMove, Q=>bStep );]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nSystemReset" Id="{fcecb133-9004-4150-b07b-7820e4041c7e}">
      <Declaration><![CDATA[METHOD M_nSystemReset : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FunONOFF:=TRUE;

M_nSystemReset:=10;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_opDbStnPCWValve" Id="{2ee84258-4512-4a13-b99c-44cb19440d6c}">
      <Declaration><![CDATA[METHOD M_opDbStnPCWValve : UDINT
VAR
	Permissive_opDbStnPCWValve			: WORD;
	Shutdown_opDbStnPCWValve			: WORD;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[FC_BitToWord(
	BOOL_00		:= TRUE, 
	BOOL_01		:= TRUE, 
	BOOL_02		:= TRUE, 
	BOOL_03		:= TRUE, 
	BOOL_04		:= TRUE, 
	BOOL_05		:= TRUE, 
	BOOL_06		:= TRUE, 
	BOOL_07		:= TRUE, 
	BOOL_08		:= TRUE, 
	BOOL_09		:= TRUE, 
	BOOL_10		:= TRUE, 
	BOOL_11		:= TRUE, 
	BOOL_12		:= TRUE, 
	BOOL_13		:= TRUE, 
	BOOL_14		:= TRUE, 
	BOOL_15		:= TRUE, 
	Output_Word		=> Permissive_opDbStnPCWValve);
	
FC_BitToWord(
	BOOL_00		:= FALSE, 
	BOOL_01		:= FALSE, 
	BOOL_02		:= FALSE, 
	BOOL_03		:= FALSE, 
	BOOL_04		:= FALSE, 
	BOOL_05		:= FALSE, 
	BOOL_06		:= FALSE, 
	BOOL_07		:= FALSE, 
	BOOL_08		:= FALSE, 
	BOOL_09		:= FALSE, 
	BOOL_10		:= FALSE, 
	BOOL_11		:= FALSE, 
	BOOL_12		:= FALSE, 
	BOOL_13		:= FALSE, 
	BOOL_14		:= FALSE, 
	BOOL_15		:= FALSE, 
	Output_Word		=> Shutdown_opDbStnPCWValve);

Precondition_opDbStnPCWValve		:=  (NOT itl_opDbStnPCWValve) AND 
										stDebugStationVIO.ipDBStnAPPresentSensor AND
										stDebugStationVIO.bSolenoidValvesOnOff;
											
Reset_opDbStnPCWValve(CLK:= Precondition_opDbStnPCWValve);
			
DUT_opDbStnPCWValve.AutInp			:= Precondition_opDbStnPCWValve;
DUT_opDbStnPCWValve.Reset			:= Reset_opDbStnPCWValve.Q;						
	
FB_opDbStnPCWValve(
	Sec_P:= Sec_P, 
	ID:= 'DbStn Main PCW Valve', 
	Simulate:= DUT_opDbStnPCWValve.Simulate, 
	Permissive:= Permissive_opDbStnPCWValve,  //check before execute
	ShutDown:= Shutdown_opDbStnPCWValve,  //keep checking this condition 
	AutoInp:= DUT_opDbStnPCWValve.AutInp, 
	Command:= DUT_opDbStnPCWValve.CMD, //1: Retract, 2: Extend, 4: Auto
	IExtend:= stDebugStationVIO.opDbStnPCWValve, 
	IRetract:= (NOT stDebugStationVIO.opDbStnPCWValve), 
	Travel_Time:= DUT_opDbStnPCWValve.Travel_Time, //detect input after output trigger
	SetOutput_Pulse:= FALSE,  //output rising edge
	FailedHoldLast:= FALSE,  //remain state after failed. 1: Remain, 0: FALSE
	OExtend=> stDebugStationVIO.opDbStnPCWValve,  //map to output variable
	ORetract=> , 
	DUT:= DUT_opDbStnPCWValve);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_RemoteSecondary24VPowerOnOff" Id="{0938c17f-e4eb-4b4c-83fd-fceaee6cab97}">
      <Declaration><![CDATA[METHOD M_RemoteSecondary24VPowerOnOff : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bPause THEN
	RETURN;
	
ELSIF itl_opDBStn24VPowerEnable THEN
	M_RemoteSecondary24VPowerOnOff					:= 20;		
	RETURN;
END_IF

IF stDbStnParam.bSecondary24VPowerOff THEN
	stDebugStationVIO.bSecondary24VPowerOnOff		:= FALSE;
	M_RemoteSecondary24VPowerOnOff					:= 10;
	
ELSIF stDbStnParam.bSecondary24VPowerOn THEN
	stDebugStationVIO.bSecondary24VPowerOnOff		:= TRUE;
	M_RemoteSecondary24VPowerOnOff					:= 10;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_RemoteSolenoidValves" Id="{6a064ceb-6458-4b2a-bd50-fd789142adf8}">
      <Declaration><![CDATA[METHOD M_RemoteSolenoidValves : INT
VAR_INPUT
END_VAR
VAR 
	i				: INT;
	On				: BOOL;
	solenoidNumber	: ARRAY [1..NO_OF_INT_PARAM] OF DINT;
	noOfSolenoids	: INT := NO_OF_INT_PARAM;
	solenoidNames	: ARRAY [1..NO_OF_INT_PARAM] OF STRING := 
						[
							'opDBStnPCWValve',
							'opDBStnMainPCWReturn',
							'opDBStnPCWSupplyPurge',
							'opDBStnPCWAWN',
							'opDBStnSupplyAirPurge',
							'opDBStnLeakFlowPCWValve',
							'opDBStnLowFlowPCWValve'
						];
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[solenoidNumber									:= stDebugStation.stGblDBStnParam.iSolenoidValves;

IF bPause THEN
	RETURN;
END_IF

IF stDbStnParam.bSolenoidValvesOff THEN
	stDebugStationVIO.bSolenoidValvesOnOff			:= FALSE;
ELSIF stDbStnParam.bSolenoidValvesOn THEN
	stDebugStationVIO.bSolenoidValvesOnOff			:= TRUE;
END_IF



FOR i:= 1 TO noOfSolenoids DO
	IF solenoidNumber[i] <> 0 THEN
		Logging.fbDebugLog.M_nLogger(
					iLogLevel			:= iLogVerbosity, sSource:= CONCAT('Turn Solenoid ', SEL(stDebugStationVIO.bSolenoidValvesOnOff, 'Off', 'On')), 
					sMessage			:= CONCAT(CONCAT(DINT_TO_STRING(solenoidNumber[i]), '. '), solenoidNames[solenoidNumber[i]])
		);
		
		CASE solenoidNumber[i] OF
			E_Solenoid.opDBStnPCWValve:
				IF itl_opDbStnPCWValve AND stDebugStationVIO.bSolenoidValvesOnOff THEN
					M_RemoteSolenoidValves							:= 20;
					RETURN;
				ELSE
					stDebugStationVIO.opDBStnPCWValve 				:= stDebugStationVIO.bSolenoidValvesOnOff;
				END_IF
				
			E_Solenoid.opDBStnMainPCWReturn:
				stDebugStationVIO.opDBStnMainPCWReturn				:= stDebugStationVIO.bSolenoidValvesOnOff;
				
			E_Solenoid.opDBStnPCWSupplyPurge:
				stDebugStationVIO.opDBStnPCWSupplyPurge				:= stDebugStationVIO.bSolenoidValvesOnOff;
				
			E_Solenoid.opDBStnPCWAWN:
				stDebugStationVIO.opDBStnPCWAWN						:= stDebugStationVIO.bSolenoidValvesOnOff;
				
			E_Solenoid.opDBStnSupplyAirPurge:
				stDebugStationVIO.opDBStnSupplyAirPurge				:= stDebugStationVIO.bSolenoidValvesOnOff;
				
			E_Solenoid.opDBStnLeakFlowPCWValve:
				stDebugStationVIO.opDBStnLeakFlowPCWValve			:= stDebugStationVIO.bSolenoidValvesOnOff;
				
			E_Solenoid.opDBStnLowFlowPCWValve:
				stDebugStationVIO.opDBStnLowFlowPCWValve			:= stDebugStationVIO.bSolenoidValvesOnOff;
		END_CASE
	END_IF
END_FOR

M_RemoteSolenoidValves			:= 10; //completed
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Secondary24VPower" Id="{182d2a69-b07b-4b03-9784-5939144db8ba}">
      <Declaration><![CDATA[METHOD M_Secondary24VPower : UDINT
VAR_INPUT
END_VAR
VAR
	Permissive_opDBStn24VPowerEnable		: WORD;
	Shutdown_opDBStn24VPowerEnable			: WORD;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FC_BitToWord(
	BOOL_00		:= TRUE, 
	BOOL_01		:= TRUE, 
	BOOL_02		:= TRUE, 
	BOOL_03		:= TRUE, 
	BOOL_04		:= TRUE, 
	BOOL_05		:= TRUE, 
	BOOL_06		:= TRUE, 
	BOOL_07		:= TRUE, 
	BOOL_08		:= TRUE, 
	BOOL_09		:= TRUE, 
	BOOL_10		:= TRUE, 
	BOOL_11		:= TRUE, 
	BOOL_12		:= TRUE, 
	BOOL_13		:= TRUE, 
	BOOL_14		:= TRUE, 
	BOOL_15		:= TRUE, 
	Output_Word		=> Permissive_opDBStn24VPowerEnable);
	
FC_BitToWord(
	BOOL_00		:= FALSE, 
	BOOL_01		:= FALSE, 
	BOOL_02		:= FALSE, 
	BOOL_03		:= FALSE, 
	BOOL_04		:= FALSE, 
	BOOL_05		:= FALSE, 
	BOOL_06		:= FALSE, 
	BOOL_07		:= FALSE, 
	BOOL_08		:= FALSE, 
	BOOL_09		:= FALSE, 
	BOOL_10		:= FALSE, 
	BOOL_11		:= FALSE, 
	BOOL_12		:= FALSE, 
	BOOL_13		:= FALSE, 
	BOOL_14		:= FALSE, 
	BOOL_15		:= FALSE, 
	Output_Word		=> Shutdown_opDBStn24VPowerEnable);
	

Precondition_opDBStn24VPowerEnable		:=  (NOT itl_opDBStn24VPowerEnable) AND 
											stDebugStationVIO.bSecondary24VPowerOnOff;
											
Reset_opDBStn24VPowerEnable(CLK:= Precondition_opDBStn24VPowerEnable);
			
DUT_opDBStn24VPowerEnable.AutInp			:= Precondition_opDBStn24VPowerEnable;
DUT_opDBStn24VPowerEnable.Reset				:= Reset_opDBStn24VPowerEnable.Q;						
	
FB_opDBStn24VPowerEnable(
	Sec_P:= Sec_P, 
	ID:= 'Cell 24V Secondary Power', 
	Simulate:= DUT_opDBStn24VPowerEnable.Simulate, 
	Permissive:= Permissive_opDBStn24VPowerEnable,  //check before execute
	ShutDown:= Shutdown_opDBStn24VPowerEnable,  //keep checking this condition 
	AutoInp:= DUT_opDBStn24VPowerEnable.AutInp, 
	Command:= DUT_opDBStn24VPowerEnable.CMD, //1: Retract, 2: Extend, 4: Auto
	IExtend:= stDebugStationVIO.opDBStn24VPowerEnable, 
	IRetract:= (NOT stDebugStationVIO.opDBStn24VPowerEnable), 
	Travel_Time:= DUT_opDBStn24VPowerEnable.Travel_Time, //detect input after output trigger
	SetOutput_Pulse:= FALSE,  //output rising edge
	FailedHoldLast:= FALSE,  //remain state after failed. 1: Remain, 0: FALSE
	OExtend=> stDebugStationVIO.opDBStn24VPowerEnable,  //map to output variable
	ORetract=> , 
	DUT:= DUT_opDBStn24VPowerEnable);
	]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_ErrClear" Id="{d9d75280-6752-4bde-84b3-4ac4c2922616}">
      <Declaration><![CDATA[PROPERTY P_ErrClear : BOOL]]></Declaration>
      <Get Name="Get" Id="{09852ed8-52da-4cfa-b7bf-5c72483fb233}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1a76478d-1f95-4e98-bdef-fc0dfd77d84d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sMessage" Id="{84e476c3-1d88-492c-b680-8ada5dd9ee0c}">
      <Declaration><![CDATA[PROPERTY P_sMessage : STRING]]></Declaration>
      <Get Name="Get" Id="{8dd0ed32-e43c-48ad-aa52-0b6cd913d8fa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{34c52a52-dcaf-4dc8-abbc-a2384fa7d2c8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_stParam" Id="{3759f916-3333-4d72-b96b-f7d2c145b9a6}">
      <Declaration><![CDATA[PROPERTY P_stParam : ST_DebugStationSeqParam]]></Declaration>
      <Get Name="Get" Id="{ee0610a6-1ba8-4b51-88e3-b93f614da113}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_stParam:=stDbStnParam;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{961d0a57-2047-43b4-bb94-6ddf2adb26c0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stDbStnParam:=P_stParam;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_stVIO" Id="{09bbf641-3822-4c05-9931-e46f775382f4}">
      <Declaration><![CDATA[PROPERTY P_stVIO : ST_DebugStation_VIO]]></Declaration>
      <Get Name="Get" Id="{2795d3d2-ce22-4e14-b01f-4b70b3b99219}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_stVIO := stDebugStationVIO;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b5c21703-4ce9-4b36-b997-6114dfabe7f8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stDebugStationVIO := P_stVIO;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Action Name="PermSD" Id="{e3ccda7f-a902-40af-82e4-b742e26b346f}">
      <Implementation>
        <ST><![CDATA[FC_BitToWord(
	BOOL_00		:= TRUE, 
	BOOL_01		:= TRUE, 
	BOOL_02		:= TRUE, 
	BOOL_03		:= TRUE, 
	BOOL_04		:= TRUE, 
	BOOL_05		:= TRUE, 
	BOOL_06		:= TRUE, 
	BOOL_07		:= TRUE, 
	BOOL_08		:= TRUE, 
	BOOL_09		:= TRUE, 
	BOOL_10		:= TRUE, 
	BOOL_11		:= TRUE, 
	BOOL_12		:= TRUE, 
	BOOL_13		:= TRUE, 
	BOOL_14		:= TRUE, 
	BOOL_15		:= TRUE, 
	Output_Word		=> Permissive_opDBStnAP240ACPwrEnable);
	
FC_BitToWord(
	BOOL_00		:= FALSE, 
	BOOL_01		:= FALSE, 
	BOOL_02		:= FALSE, 
	BOOL_03		:= FALSE, 
	BOOL_04		:= FALSE, 
	BOOL_05		:= FALSE, 
	BOOL_06		:= FALSE, 
	BOOL_07		:= FALSE, 
	BOOL_08		:= FALSE, 
	BOOL_09		:= FALSE, 
	BOOL_10		:= FALSE, 
	BOOL_11		:= FALSE, 
	BOOL_12		:= FALSE, 
	BOOL_13		:= FALSE, 
	BOOL_14		:= FALSE, 
	BOOL_15		:= FALSE, 
	Output_Word		=> Shutdown_opDBStnAP240ACPwrEnable);]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_DebugStationSeq">
      <LineId Id="9" Count="0" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.Conversion">
      <LineId Id="15" Count="1" />
      <LineId Id="139" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="17" Count="7" />
      <LineId Id="140" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="25" Count="7" />
      <LineId Id="143" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="144" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="41" Count="6" />
      <LineId Id="107" Count="3" />
      <LineId Id="114" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="121" Count="3" />
      <LineId Id="126" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="48" Count="32" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.INC">
      <LineId Id="11" Count="9" />
      <LineId Id="26" Count="0" />
      <LineId Id="21" Count="4" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_AP240Power">
      <LineId Id="124" Count="0" />
      <LineId Id="187" Count="12" />
      <LineId Id="220" Count="1" />
      <LineId Id="202" Count="17" />
      <LineId Id="92" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="182" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_InputBackDoor">
      <LineId Id="6" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="7" Count="4" />
      <LineId Id="90" Count="0" />
      <LineId Id="12" Count="4" />
      <LineId Id="91" Count="0" />
      <LineId Id="17" Count="5" />
      <LineId Id="92" Count="0" />
      <LineId Id="23" Count="4" />
      <LineId Id="93" Count="0" />
      <LineId Id="28" Count="4" />
      <LineId Id="94" Count="0" />
      <LineId Id="33" Count="4" />
      <LineId Id="95" Count="0" />
      <LineId Id="38" Count="4" />
      <LineId Id="96" Count="0" />
      <LineId Id="43" Count="5" />
      <LineId Id="97" Count="0" />
      <LineId Id="49" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="54" Count="2" />
      <LineId Id="58" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="67" Count="4" />
      <LineId Id="63" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="61" Count="1" />
      <LineId Id="57" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_InterlockTII">
      <LineId Id="6" Count="0" />
      <LineId Id="65" Count="5" />
      <LineId Id="10" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="71" Count="5" />
      <LineId Id="16" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="77" Count="7" />
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="85" Count="6" />
      <LineId Id="28" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="92" Count="7" />
      <LineId Id="45" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_IOMapping">
      <LineId Id="1516" Count="0" />
      <LineId Id="1518" Count="0" />
      <LineId Id="1517" Count="0" />
      <LineId Id="1520" Count="0" />
      <LineId Id="1519" Count="0" />
      <LineId Id="1521" Count="1" />
      <LineId Id="1220" Count="0" />
      <LineId Id="1464" Count="0" />
      <LineId Id="1371" Count="0" />
      <LineId Id="1465" Count="0" />
      <LineId Id="1535" Count="0" />
      <LineId Id="1467" Count="1" />
      <LineId Id="1470" Count="0" />
      <LineId Id="1523" Count="2" />
      <LineId Id="1466" Count="0" />
      <LineId Id="1392" Count="0" />
      <LineId Id="1246" Count="3" />
      <LineId Id="1251" Count="0" />
      <LineId Id="1254" Count="0" />
      <LineId Id="1256" Count="0" />
      <LineId Id="1409" Count="0" />
      <LineId Id="1258" Count="1" />
      <LineId Id="1385" Count="1" />
      <LineId Id="1402" Count="0" />
      <LineId Id="1412" Count="0" />
      <LineId Id="1407" Count="0" />
      <LineId Id="1405" Count="0" />
      <LineId Id="1413" Count="0" />
      <LineId Id="163" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nCyclic">
      <LineId Id="188" Count="1" />
      <LineId Id="272" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="193" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="200" Count="0" />
      <LineId Id="215" Count="2" />
      <LineId Id="219" Count="0" />
      <LineId Id="235" Count="2" />
      <LineId Id="321" Count="0" />
      <LineId Id="324" Count="1" />
      <LineId Id="238" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="239" Count="11" />
      <LineId Id="252" Count="9" />
      <LineId Id="288" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nDPSPowerOnOff">
      <LineId Id="6" Count="3" />
      <LineId Id="337" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="359" Count="2" />
      <LineId Id="12" Count="1" />
      <LineId Id="367" Count="3" />
      <LineId Id="372" Count="3" />
      <LineId Id="279" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="40" Count="7" />
      <LineId Id="49" Count="1" />
      <LineId Id="57" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="325" Count="4" />
      <LineId Id="61" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="293" Count="20" />
      <LineId Id="388" Count="0" />
      <LineId Id="314" Count="3" />
      <LineId Id="290" Count="0" />
      <LineId Id="94" Count="1" />
      <LineId Id="163" Count="0" />
      <LineId Id="165" Count="10" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nSystemReset">
      <LineId Id="9" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_opDbStnPCWValve">
      <LineId Id="6" Count="36" />
      <LineId Id="59" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="85" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_RemoteSecondary24VPowerOnOff">
      <LineId Id="6" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_RemoteSolenoidValves">
      <LineId Id="21" Count="3" />
      <LineId Id="32" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="50" Count="6" />
      <LineId Id="95" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="62" Count="16" />
      <LineId Id="80" Count="1" />
      <LineId Id="49" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="108" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_Secondary24VPower">
      <LineId Id="9" Count="35" />
      <LineId Id="5" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="51" Count="20" />
      <LineId Id="50" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_ErrClear.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_ErrClear.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_sMessage.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_sMessage.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stParam.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stParam.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stVIO.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stVIO.Set">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.PermSD">
      <LineId Id="2" Count="35" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>