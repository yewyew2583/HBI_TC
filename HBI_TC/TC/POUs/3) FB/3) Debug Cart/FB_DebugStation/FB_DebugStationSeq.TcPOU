<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_DebugStationSeq" Id="{09f9be3c-5add-4051-b26d-1258202fe318}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DebugStationSeq EXTENDS Tc3_HBI_System.FB_Basic
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	nI : UINT;
	
	stDebugStationBIO		:ST_DebugStation_BIO;
	stDebugStationDIO		:ST_DebugStation_DIO;
	stDebugStationVIO		:ST_DebugStation_VIO;
	stDbColVIO				: ST_DebugColumnDIO;
	
	stDbStnParam : ST_DebugStationSeqParam;
	fbBD_ipBdoor : Tc3_HBI_Utilities.FB_BackDoor_Digital;
	
	btest: BOOL;

	DIFUOn_TstPwr:R_TRIG;
	DIFUOn_AP240Pwr:R_TRIG;
	DIFUSet_bChkTstOn:R_TRIG; 	//
	DIFUAPPresent:R_TRIG;
	DIFDAPPresent:F_TRIG;
	DIFUSet_bChkAP240On:R_TRIG; 	//
	
	FB_opDBStnAP240ACPwrEnable					: DFB_Cylinder;
	DUT_opDBStnAP240ACPwrEnable					: DUT_Cylinder;
	Permissive_opDBStnAP240ACPwrEnable			: WORD;
	Shutdown_opDBStnAP240ACPwrEnable			: WORD;
	Reset_opDBStnAP240ACPwrEnable				: R_TRIG;
	Precondition_opDBStnAP240ACPwrEnable		: BOOL;
	_Alarm										: BOOL;
	
	
	tstOnCheckTim:TON;		//delay to check TesterOnFeedback
	ap240OnCheckTim:TON;		//delay to check AP240OnFeedback
	tstPresentTim:TON;		//delay to On Tester Air Valve after Tester Present
	apPresentTimer:TON;
	
	isLeakage:BOOL;
	isGroundFault:BOOL;
	
		// Common var 
	bPause : BOOL; //Sequence pause
	bBypassSingleMove : BOOL:=TRUE;
	bStep : BOOL;
	rtStep: R_TRIG;
	rtStepCase: R_TRIG;
	rtError: R_TRIG;
	iStkSeqCase : INT;
	iSeqStep: INT;
	iSysRsetSeqStep: INT;
	arrSeqStep: ARRAY [0..50] OF E_SeqSts; 			// seq
	arrSysRsetSeqStep: ARRAY [0..50] OF E_SeqSts; 	//Sys Rset seq
	
	sMessage : STRING;
	bErrClear: BOOL;
	bStepDone: BOOL;
	bSafeExecute: BOOL;
	iStkSingStackUp:INT;
	iLibrySts : ARRAY [1..20] OF UDINT;
	
	
	
	tAPACPwrDelayToComplete		:TON;  	//AP240ACPowerOnOff
	tAPACPwrDelayToAutoComplete	:TON;	//AP240ACPowerAuto
	
	
	timInc:TON;
	bTIISenSimArray:ARRAY[1..NO_OF_TII_SENSOR] OF BOOL;
	TimTemp:TON;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
]]></ST>
    </Implementation>
    <Method Name="Conversion" Id="{a226b9d3-12c7-467d-870e-e671e401b57e}">
      <Declaration><![CDATA[METHOD Conversion : BOOL
VAR_INPUT
	isSimulation : BOOL;
	//dIO:ST_DebugStation_DIO;
END_VAR
VAR		
	tempSimIpt:LREAL;
END_VAR
VAR_IN_OUT
	//vIO:ST_DebugStation_VIO;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF isSimulation THEN
	//GetRand(Seed:=0,Num=>tempSimIpt);
	//stDebugStationDIO.simDBStnTstAirLeakFlowSensor := tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnTstAirLeakFlowSensor(Mn:=spDBStnTstAirLeakFlowSensor.iMn, mx:=spDBStnTstAirLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnTstAirLeakFlowSensor);
	//stDebugStationDIO.simDBStnTstAirLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnTstAirLeakFlowSensor));							
	stDebugStationDIO.ipDBStnTstAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnTstAirLeakFlowSensor.iMn, 
																	iMx:= spDBStnTstAirLeakFlowSensor.iMx, 
																	oMn:= spDBStnTstAirLeakFlowSensor.oMn, 
																	oMx:= spDBStnTstAirLeakFlowSensor.oMx, 
																	ofs:= spDBStnTstAirLeakFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnTstAirLeakFlowSensor) , 
																	b  := spDBStnTstAirLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.ipDBStnAPAirLeakFlowSensor :=tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnAPAirLeakFlowSensor(Mn:=spDBStnAPAirLeakFlowSensor.iMn, mx:=spDBStnAPAirLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnAPAirLeakFlowSensor);
	//stDebugStationDIO.ipDBStnAPAirLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnTstAirLeakFlowSensor));															
	stDebugStationDIO.ipDBStnAPAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnAPAirLeakFlowSensor.iMn, 
																	iMx:= spDBStnAPAirLeakFlowSensor.iMx, 
																	oMn:= spDBStnAPAirLeakFlowSensor.oMn, 
																	oMx:= spDBStnAPAirLeakFlowSensor.oMx, 
																	ofs:= spDBStnAPAirLeakFlowSensor.ofs, 
																	val:=  LREAL_TO_INT(stDebugStationDIO.simDBStnAPAirLeakFlowSensor) , 
																	b  := spDBStnAPAirLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.simDBStnPCWLeakFlowSensor := tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnPCWLeakFlowSensor(Mn:=spDBStnPCWLeakFlowSensor.iMn, mx:=spDBStnPCWLeakFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnPCWLeakFlowSensor);
	//stDebugStationDIO.simDBStnPCWLeakFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnPCWLeakFlowSensor));
	stDebugStationDIO.ipDBStnPCWLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLeakFlowSensor.iMn, 
																	iMx:= spDBStnPCWLeakFlowSensor.iMx, 
																	oMn:= spDBStnPCWLeakFlowSensor.oMn, 
																	oMx:= spDBStnPCWLeakFlowSensor.oMx, 
																	ofs:= spDBStnPCWLeakFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnPCWLeakFlowSensor) , 
																	b  := spDBStnPCWLeakFlowSensor.b);
	//GetRand(Seed:=0,Num=>tempSimIpt);	
	//stDebugStationDIO.simDBStnPCWLowFlowSensor :=tempSimIpt*10000;
	stDebugStationDIO.fbSimDBStnPCWLowFlowSensor(Mn:=spDBStnPCWLowFlowSensor.iMn, mx:=spDBStnPCWLowFlowSensor.iMx, Sen:= stDebugStationDIO.simDBStnPCWLowFlowSensor);
	//stDebugStationDIO.simDBStnPCWLowFlowSensor := INC(IN:=LREAL_TO_INT (stDebugStationDIO.simDBStnPCWLowFlowSensor));
	stDebugStationDIO.ipDBStnPCWLowFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLowFlowSensor.iMn, 
																	iMx:= spDBStnPCWLowFlowSensor.iMx, 
																	oMn:= spDBStnPCWLowFlowSensor.oMn, 
																	oMx:= spDBStnPCWLowFlowSensor.oMx, 
																	ofs:= spDBStnPCWLowFlowSensor.ofs, 
																	val:= LREAL_TO_INT(stDebugStationDIO.simDBStnPCWLowFlowSensor) , 
																	b  := spDBStnPCWLowFlowSensor.b);
	IF NOT bDebugStation THEN
		stDebugStationDIO.ipDBStnTstAirLeakFlowSensor 	:=
		stDebugStationDIO.ipDBStnAPAirLeakFlowSensor 	:=
		stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=
		stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
	ELSE
		IF stDebugStationDIO.opDBStnPCWFlowBypassValve THEN
			stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=
			stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
		ELSE
			IF NOT stDebugStationDIO.opDBStnLeakFlowPCWValve THEN
				stDebugStationDIO.ipDBStnPCWLeakFlowSensor 		:=0;
			END_IF
			IF NOT stDebugStationDIO.opDBStnLowFlowPCWValve THEN
				stDebugStationDIO.ipDBStnPCWLowFlowSensor 		:=0;
			END_IF
		END_IF
	END_IF	
	
ELSE
	stDebugStationDIO.ipDBStnTstAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnTstAirLeakFlowSensor.iMn, 
																iMx:= spDBStnTstAirLeakFlowSensor.iMx, 
																oMn:= spDBStnTstAirLeakFlowSensor.oMn, 
																oMx:= spDBStnTstAirLeakFlowSensor.oMx, 
																ofs:= spDBStnTstAirLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnTstAirLeakFlowSensor , 
																b  := spDBStnTstAirLeakFlowSensor.b);
																
	stDebugStationDIO.ipDBStnAPAirLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnAPAirLeakFlowSensor.iMn, 
																iMx:= spDBStnAPAirLeakFlowSensor.iMx, 
																oMn:= spDBStnAPAirLeakFlowSensor.oMn, 
																oMx:= spDBStnAPAirLeakFlowSensor.oMx, 
																ofs:= spDBStnAPAirLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnAPAirLeakFlowSensor , 
																b  := spDBStnAPAirLeakFlowSensor.b);

	stDebugStationDIO.ipDBStnPCWLeakFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLeakFlowSensor.iMn, 
																iMx:= spDBStnPCWLeakFlowSensor.iMx, 
																oMn:= spDBStnPCWLeakFlowSensor.oMn, 
																oMx:= spDBStnPCWLeakFlowSensor.oMx, 
																ofs:= spDBStnPCWLeakFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnPCWLeakFlowSensor , 
																b  := spDBStnPCWLeakFlowSensor.b);

	stDebugStationDIO.ipDBStnPCWLowFlowSensor	:= 	ANLG_TO_ABC(iMn:= spDBStnPCWLowFlowSensor.iMn, 
																iMx:= spDBStnPCWLowFlowSensor.iMx, 
																oMn:= spDBStnPCWLowFlowSensor.oMn, 
																oMx:= spDBStnPCWLowFlowSensor.oMx, 
																ofs:= spDBStnPCWLowFlowSensor.ofs, 
																val:= stDebugStationDIO.ipAnlgDBStnPCWLowFlowSensor , 
																b  := spDBStnPCWLowFlowSensor.b);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="INC" Id="{898b9e45-f951-4f57-91d5-d720dcc3f9a3}">
      <Declaration><![CDATA[METHOD INC : UDINT
VAR_INPUT
	IN:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*IF timInc.Q THEN
	IF IN >= 32768 THEN
		INC := 0; 
	ELSE
		INC := IN+500; 
	END_IF
	timInc(IN:=FALSE);
ELSE
	timInc(IN:=TRUE,PT:=T#500MS);
END_IF
*)

	IF IN >= 32768 THEN
		INC := 0; 
	ELSE
		INC := IN+5; 
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AP240Power" Id="{8b504b38-c8b9-4f13-804b-f71cac2517bc}">
      <Declaration><![CDATA[METHOD M_AP240Power : UDINT
VAR_INPUT
END_VAR
VAR 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// new implementation motor
PermSD();

IF DewPoint_Abort OR OFA6Bar_Abort THEN
	_Alarm		:= TRUE;
ELSIF (NOT ALM_DCCOL.AlarmID[E_DCFACAlarm.eCriticalCondensationAlarm]) AND (NOT ALM_DCCOL.AlarmID[E_DCFACAlarm.e6BarLowOFAAirPressureAlarm]) THEN
	_Alarm		:= FALSE;
END_IF

Precondition_opDBStnAP240ACPwrEnable	:= (stDebugStationVIO.ipDBStnAPPresentSensor AND (NOT isLeakage) AND (NOT isGroundFault) AND (NOT _Alarm))
											AND Ap240AcPowerMode <> 1;

Reset_opDBStnAP240ACPwrEnable(CLK:= precondition_opDBStnAP240ACPwrEnable);

DUT_opDBStnAP240ACPwrEnable.AutInp		:= Precondition_opDBStnAP240ACPwrEnable;
DUT_opDBStnAP240ACPwrEnable.Reset		:= Reset_opDBStnAP240ACPwrEnable.Q;
DUT_opDBStnAP240ACPwrEnable.Travel_Time	:= 5;
											
											
FB_opDBStnAP240ACPwrEnable(
	Sec_P		:= Sec_P, 
	ID		:= 'DebugCart AP240Power', 
	Simulate		:= DUT_opDBStnAP240ACPwrEnable.Simulate, 
	Permissive		:= Permissive_opDBStnAP240ACPwrEnable, 
	ShutDown		:= Shutdown_opDBStnAP240ACPwrEnable, 
	AutoInp		:= DUT_opDBStnAP240ACPwrEnable.AutInp, 
	Command		:= DUT_opDBStnAP240ACPwrEnable.CMD, 
	IExtend		:= stDebugStationVIO.ipDBStnAPPowerOn, 
	IRetract		:= (NOT stDebugStationVIO.ipDBStnAPPowerOn), 
	Travel_Time		:= DUT_opDBStnAP240ACPwrEnable.Travel_Time, 
	SetOutput_Pulse		:= FALSE, 
	FailedHoldLast		:= FALSE,
	OExtend		=> stDebugStationVIO.opDBStnAP240ACPwrEnable, 
	ORetract		=> , 
	DUT		:= DUT_opDBStnAP240ACPwrEnable);
//</APPowerOn>

GVL_DUT_DC_AP240ACPower		:= DUT_opDBStnAP240ACPwrEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IOMapping" Id="{a72e6ef1-5a7c-4aa4-b869-c7c8e540ce38}">
      <Declaration><![CDATA[METHOD M_IOMapping : BOOL
VAR_INPUT
	
END_VAR

VAR
bSimu:BOOL:=FALSE;
	stMLVIO: INT;
	ipDBStnAPPowerOn: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[stDebugStationVIO.ipDBStnAPPresentSensor		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode AND NOT bTIISenSimArray[E_TIIAlarm.ipAPPresentSensor], 
	                                            					bActual:= stDebugStationDIO.ipDBStnAPPresentSensor, 
	                                            					bSimu:=TRUE , 
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnAPPresentSensor );
																	
stDebugStationVIO.ipDBStnAPPowerOn		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode AND NOT bTIISenSimArray[E_TIIAlarm.ipAPPowerOn],
	                                            					bActual:= stDebugStationDIO.ipDBStnAPPowerOn, 
	                                            					bSimu:=TRUE , 
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnAPPowerOn );													

stDebugStationVIO.ipDBStnAPReady		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode AND NOT bTIISenSimArray[E_TIIAlarm.ipAPReady],
	                                            					bActual:=stDebugStationDIO.ipDBStnAPReady , 
	                                            					bSimu:=TRUE , 
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnAPReady );	


stDebugStationVIO.ipDBStnHandlerSafeToEnterPLC		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode , 
	                                            					bActual:=stDebugStationDIO.ipDBStnHandlerSafeToEnterPLC , 
	                                            					bSimu:=FALSE , 
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnHandlerSafeToEnterPLC );	

stDebugStationVIO.ipDBStnHandlerSafeToEnterHwr		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode , 
	                                            					bActual:=stDebugStationDIO.ipDBStnHandlerSafeToEnterHwr ,
	                                            					bSimu:=FALSE ,
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnHandlerSafeToEnterHwr );

stDebugStationVIO.ipDBStnCellGroundFault		:= fbBD_ipBdoor.M_bBackDoorCtrl(bProductionMode:=bProductionMode , 
	                                            					bActual:=stDebugStationDIO.ipDBStnCellGroundFault , 
	                                            					bSimu:=FALSE , 
	                                            					iBackDoor:=stDebugStationBIO.ipDBStnCellGroundFault );
																	

isLeakage		:=( ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm] OR ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm] OR 
					ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm]);																
isGroundFault		:= ALMTC.Level[1].AlarmID[E_TIIAlarm.ipCellGroundFault];															
																	
//<LOOP>	
	M_AP240Power();
//</LOOP>																


//<24VSencondaryPwr>
	IF stDebugStationVIO.ipDBStnAPPresentSensor AND NOT (isLeakage OR isGroundFault) THEN//AND NOT ( ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm] OR ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm] OR ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm]) THEN
		stDebugStationVIO.opDBStn24VPowerEnable:=TRUE;
	ELSE
		stDebugStationVIO.opDBStn24VPowerEnable:=FALSE;
	END_IF
//<24VSencondaryPwr>>
//stDbColVIO := fbDebugColumn.P_stVIO;

IF ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWLeakageAlarm] OR ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWSupplyLeakageAlarm] OR ALM_DCCOL.AlarmID[E_DCFACAlarm.eSystemPCWReturnLeakageAlarm] THEN
	stDebugStationDIO.opDBStnPCWValve    := FALSE;																
END_IF
																	
stDebugStationVIO.opDBStnAPSafeToEngage := 	stDebugStationVIO.ipDBStnAPPresentSensor;
														
IF NOT stDebugStationVIO.bDiagnosticMode	THEN										
	
	
	stDebugStationDIO.ipDBStnTstAirLeakFlowSensor 		:= stDebugStationVIO.ipDBStnTstAirLeakFlowSensor;
	stDebugStationDIO.ipDBStnAPAirLeakFlowSensor 		:= stDebugStationVIO.ipDBStnAPAirLeakFlowSensor;
	stDebugStationDIO.ipDBStnPCWLeakFlowSensor 			:= stDebugStationVIO.ipDBStnPCWLeakFlowSensor;
	stDebugStationDIO.ipDBStnPCWLowFlowSensor 			:= stDebugStationVIO.ipDBStnPCWLowFlowSensor;
	
	
	
	stDebugStationDIO.opDBStnAP240ACPwrEnable			:= stDebugStationVIO.opDBStnAP240ACPwrEnable;			
	stDebugStationDIO.opAP_DIO_1						:= stDebugStationVIO.opAP_DIO_1;
	stDebugStationDIO.opAP_DIO_2						:= stDebugStationVIO.opAP_DIO_2;
	stDebugStationDIO.opAP_DIO_3						:= stDebugStationVIO.opAP_DIO_3;
	IF stDebugStationVIO.ipDBStnAPPresentSensor THEN
		stDebugStationDIO.opDBStnPCWValve				:= stDebugStationVIO.opDBStnPCWValve;
	END_IF
	stDebugStationDIO.opDBStnPCWFlowBypassValve         := stDebugStationVIO.opDBStnPCWFlowBypassValve;
	stDebugStationDIO.opDBStnBypassAPAirSupplySol       := stDebugStationVIO.opDBStnBypassAPAirSupplySol;
	stDebugStationDIO.opDBStn24VPowerEnable             := stDebugStationVIO.opDBStn24VPowerEnable;
	stDebugStationDIO.opDBStnLeakFlowPCWValve           := stDebugStationVIO.opDBStnLeakFlowPCWValve;
	stDebugStationDIO.opDBStnLowFlowPCWValve            := stDebugStationVIO.opDBStnLowFlowPCWValve;
	stDebugStationDIO.opDBStnAPSafeToEngage         	:= stDebugStationVIO.opDBStnAPSafeToEngage;
	stDebugStationDIO.opDBStnAPTCCReset                 := stDebugStationVIO.opDBStnAPTCCReset;
	stDebugStationDIO.opDBStnMainPCWReturn				:= stDebugStationVIO.opDBStnMainPCWReturn;
	stDebugStationDIO.opDBStnPCWSupplyPurge				:= stDebugStationVIO.opDBStnPCWSupplyPurge;
	stDebugStationDIO.opCellLTIMValve					:= stDebugStationVIO.opCellLTIMValve;
	stDebugStationDIO.opDBStnAlarmLED					:= stDebugStationVIO.opDBStnAlarmLED;
	stDebugStationDIO.opDBStnPurgeLED					:= stDebugStationVIO.opDBStnPurgeLED;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nCyclic" Id="{7475bd0d-875c-4872-a0ee-0a195890a3a7}">
      <Declaration><![CDATA[METHOD M_nCyclic : UDINT
VAR_INPUT
END_VAR


VAR
	//stTCM: INT;
	stGblParam: INT;
	varTest:bool;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//M_nCompCylinder(bExtend:=TRUE, fbTCDrawerUp, sMsg);
//M_IOMapping();
Conversion(isSimulation:=bAnalogIOSim);
M_IOMapping();

rtError(CLK:=_bError, Q=> );
btest:=TRUE;

	//fbTCDrawerExtRet.M_nReset(bExecute:=_bReset OR rtError.Q );
	//fbTCDrawerUpDn.M_nReset(bExecute:=_bReset OR rtError.Q );
		
IF _bReset OR bStepDone OR rtError.Q THEN
	//inTCDrawerExtRet.M_nOff();
	//inTCDrawerUpDn.M_nOff();
	
	//sensor

	FOR nI:=1 TO 20 DO 
		iLibrySts[1] := 0;
	END_FOR
	
	bStepDone:=FALSE; 
END_IF

//inTCDrawerExtRet.P_SensorDelay:= 	FB_M_nCyclic_tSensorDelay  ;  //T#12S; 
//inTCDrawerExtRet.P_Timeout:= 		FB_M_nCyclic_tSensorTimeOut; //T#30S;;    

//inTCDrawerUpDn.P_SensorDelay:= FB_M_nCyclic_tSensorDelay;
//inTCDrawerUpDn.P_Timeout:= FB_M_nCyclic_tSensorTimeOut;

(*IF stTCSeqParam.bInitComplt THEN //temp...This portion will be done by Initialise sequence
END_IF*)
	
IF _bReset THEN
	IF stDbStnParam.bInitialise THEN
		iSysRsetSeqStep:=0;
	ELSE
		iSeqStep:=0;
	END_IF
	iStkSeqCase:=0;
	bStepDone:=FALSE;
	sMessage:='';
	_bError:=FALSE;
	_nErrorID:=0;
ELSIF bErrClear THEN
	_bError:=FALSE;
	_nErrorID:=0;
	bErrClear:=FALSE;
END_IF

bPause:=_bReset OR _bError OR bErrClear;
//M_StkSingStackUp state
IF _bError THEN
	iStkSingStackUp:=99;
ELSIF _bReset THEN
	iStkSingStackUp:=0;
ELSIF iStkSeqCase=E_SeqSts.eDone THEN
	iStkSingStackUp:=10;
ELSIF NOT bPause THEN
	iStkSingStackUp:=3;
END_IF

//inTCDrawerExtRet.P_nExtendAlarmID:=E_AlarmID.DrawerExtendError;
//inTCDrawerExtRet.P_nRetractAlarmID:=E_AlarmID.DrawerRetractError;
//inTCDrawerUpDn	 .P_nExtendAlarmID:=E_AlarmID.DrawerUpError;
//inTCDrawerUpDn	 .P_nRetractAlarmID:=E_AlarmID.DrawerDownError;

(*IF (NOT stMLVIO.ipTCDrawerCylRetractRS AND stMLVIO.ipTCDrawerCylExtendRS) THEN
	stMLVIO.bTIUInOutStatusFlag:= TRUE;
ELS*)
//IF stMLVIO.ipTCDrawerCylRetractRS AND NOT stMLVIO.ipTCDrawerCylExtendRS THEN
//	stMLVIO.bTIUInOutStatusFlag:= FALSE;
//ELSE
//	stMLVIO.bTIUInOutStatusFlag:= TRUE;
//END_IF

//stMLVIO.opAlarmLED:= stMLVIO.isTIIError OR _bError OR stMLVIO.isSysError;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nDPSPowerOnOff" Id="{be69dcd0-a948-487b-8886-639ea27a5501}">
      <Declaration><![CDATA[METHOD M_nDPSPowerOnOff : INT
VAR_INPUT
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_nDPSPowerOnOff:=iStkSingStackUp;

IF bPause THEN
	RETURN;

ELSIF stDebugStationVIO.isTIIError OR stDebugStationVIO.isSysError THEN  
	IF FALSE (*DIFU Cyl Tii Err*) THEN
	;
	ELSE
		M_nDPSPowerOnOff:=20;		
		RETURN;
	END_IF
END_IF
IF iSeqStep>0 THEN
	;//Do nothing;
	
ELSIF stDbStnParam.bAP240ACPowerOff OR
	  stDbStnParam.bAP240ACPowerOn OR
	  stDbStnParam.bAP240ACPowerAuto 
	  THEN
	arrSeqStep[0]:=E_SeqSts.eInit;						//Init
	arrSeqStep[1]:=E_SeqSts.eSanityCheckForAPPwr;		//Sanity check
	arrSeqStep[2]:=E_SeqSts.eAP240ACPwrOnOff;			//AP240ACPowerOnOff
	arrSeqStep[3]:=E_SeqSts.eDone;						//Done
	
END_IF


//Sequence start
iStkSeqCase:=arrSeqStep[iSeqStep];

// State machine
CASE iStkSeqCase OF
E_SeqSts.eInit: //Init
	//TDelay(IN:=FALSE);
	sMessage:='Start Executing';
	bStepDone:=TRUE;


E_SeqSts.eSanityCheckForAPPwr: 				//Sanity check AP
	sMessage:='CheckTeir2IIAlarm';
	
	tAPACPwrDelayToComplete(IN:=FALSE);
	tAPACPwrDelayToAutoComplete(IN:=FALSE);
	bStepDone:=TRUE;	
	
E_SeqSts.eAP240ACPwrOnOff:										// AP240ACPowerOnOff
		tAPACPwrDelayToComplete(IN:=TRUE, PT:=T#2S); 			// origin T#10s
		IF tAPACPwrDelayToComplete.Q THEN
			IF stDbStnParam.bAP240ACPowerOff THEN 			(*0=Off, 1=On, 2=Auto(Off->On) *)
				stDebugStationVIO.bAP240ACPowerOnOff:=FALSE;//TRUE;
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#0S);
				sMessage:='AP240AC PowerOff';
				Ap240AcPowerMode		:= 1;
			ELSIF stDbStnParam.bAP240ACPowerOn THEN
				stDebugStationVIO.bAP240ACPowerOnOff		:= TRUE;//FALSE;
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#0S);
				sMessage:='AP240AC PowerOn';
				Ap240AcPowerMode		:= 2;
			ELSIF  stDbStnParam.bAP240ACPowerAuto THEN
				stDebugStationVIO.bAP240ACPowerOnOff:=FALSE;//TRUE;
				sMessage:='AP240AC PowerOff';
				Ap240AcPowerMode		:= 1;
				tAPACPwrDelayToAutoComplete(IN:=TRUE, PT:=T#2S); // origin T#10s
				IF tAPACPwrDelayToAutoComplete.Q THEN
					stDebugStationVIO.bAP240ACPowerOnOff:=TRUE;//FALSE;	
					sMessage:='AP240AC PowerOn';
					Ap240AcPowerMode		:= 2;
				END_IF
			END_IF
		END_IF
IF tAPACPwrDelayToComplete.Q AND tAPACPwrDelayToAutoComplete.Q THEN
	tAPACPwrDelayToComplete(IN:=FALSE);
	tAPACPwrDelayToAutoComplete(IN:=FALSE);
	bStepDone:=TRUE;
END_IF

	
E_SeqSts.eDone:	// Done
	sMessage:='Done';
	M_nDPSPowerOnOff:=10;
END_CASE	

(*IF _nErrorID>0 OR _bError THEN
	_bError:=TRUE;
ELS*)
IF (bStep OR bBypassSingleMove OR iStkSeqCase<=E_SeqSts.eSanityCheck) 
AND iStkSeqCase<E_SeqSts.eDone AND bStepDone THEN
	iSeqStep:=iSeqStep+1;
END_IF

rtStep(CLK:=bStep AND NOT bBypassSingleMove, Q=>bStep );]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_nSystemReset" Id="{fcecb133-9004-4150-b07b-7820e4041c7e}">
      <Declaration><![CDATA[METHOD M_nSystemReset : INT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FunONOFF:=TRUE;

M_nSystemReset:=10;]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_ErrClear" Id="{d9d75280-6752-4bde-84b3-4ac4c2922616}">
      <Declaration><![CDATA[PROPERTY P_ErrClear : BOOL]]></Declaration>
      <Get Name="Get" Id="{09852ed8-52da-4cfa-b7bf-5c72483fb233}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1a76478d-1f95-4e98-bdef-fc0dfd77d84d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_sMessage" Id="{84e476c3-1d88-492c-b680-8ada5dd9ee0c}">
      <Declaration><![CDATA[PROPERTY P_sMessage : STRING]]></Declaration>
      <Get Name="Get" Id="{8dd0ed32-e43c-48ad-aa52-0b6cd913d8fa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{34c52a52-dcaf-4dc8-abbc-a2384fa7d2c8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_stParam" Id="{3759f916-3333-4d72-b96b-f7d2c145b9a6}">
      <Declaration><![CDATA[PROPERTY P_stParam : ST_DebugStationSeqParam]]></Declaration>
      <Get Name="Get" Id="{ee0610a6-1ba8-4b51-88e3-b93f614da113}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_stParam:=stDbStnParam;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{961d0a57-2047-43b4-bb94-6ddf2adb26c0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stDbStnParam:=P_stParam;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_stVIO" Id="{09bbf641-3822-4c05-9931-e46f775382f4}">
      <Declaration><![CDATA[PROPERTY P_stVIO : ST_DebugStation_VIO]]></Declaration>
      <Get Name="Get" Id="{2795d3d2-ce22-4e14-b01f-4b70b3b99219}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_stVIO := stDebugStationVIO;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b5c21703-4ce9-4b36-b997-6114dfabe7f8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stDebugStationVIO := P_stVIO;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Action Name="PermSD" Id="{e3ccda7f-a902-40af-82e4-b742e26b346f}">
      <Implementation>
        <ST><![CDATA[FC_BitToWord(
	BOOL_00		:= TRUE, 
	BOOL_01		:= TRUE, 
	BOOL_02		:= TRUE, 
	BOOL_03		:= TRUE, 
	BOOL_04		:= TRUE, 
	BOOL_05		:= TRUE, 
	BOOL_06		:= TRUE, 
	BOOL_07		:= TRUE, 
	BOOL_08		:= TRUE, 
	BOOL_09		:= TRUE, 
	BOOL_10		:= TRUE, 
	BOOL_11		:= TRUE, 
	BOOL_12		:= TRUE, 
	BOOL_13		:= TRUE, 
	BOOL_14		:= TRUE, 
	BOOL_15		:= TRUE, 
	Output_Word		=> Permissive_opDBStnAP240ACPwrEnable);
	
FC_BitToWord(
	BOOL_00		:= FALSE, 
	BOOL_01		:= FALSE, 
	BOOL_02		:= FALSE, 
	BOOL_03		:= FALSE, 
	BOOL_04		:= FALSE, 
	BOOL_05		:= FALSE, 
	BOOL_06		:= FALSE, 
	BOOL_07		:= FALSE, 
	BOOL_08		:= FALSE, 
	BOOL_09		:= FALSE, 
	BOOL_10		:= FALSE, 
	BOOL_11		:= FALSE, 
	BOOL_12		:= FALSE, 
	BOOL_13		:= FALSE, 
	BOOL_14		:= FALSE, 
	BOOL_15		:= FALSE, 
	Output_Word		=> Shutdown_opDBStnAP240ACPwrEnable);]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_DebugStationSeq">
      <LineId Id="9" Count="0" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.Conversion">
      <LineId Id="15" Count="1" />
      <LineId Id="139" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="17" Count="7" />
      <LineId Id="140" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="25" Count="7" />
      <LineId Id="143" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="144" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="41" Count="6" />
      <LineId Id="107" Count="3" />
      <LineId Id="114" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="121" Count="3" />
      <LineId Id="126" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="48" Count="32" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.INC">
      <LineId Id="11" Count="9" />
      <LineId Id="26" Count="0" />
      <LineId Id="21" Count="4" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_AP240Power">
      <LineId Id="124" Count="0" />
      <LineId Id="187" Count="12" />
      <LineId Id="220" Count="1" />
      <LineId Id="202" Count="17" />
      <LineId Id="92" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="182" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_IOMapping">
      <LineId Id="1110" Count="32" />
      <LineId Id="1286" Count="0" />
      <LineId Id="1144" Count="1" />
      <LineId Id="1220" Count="0" />
      <LineId Id="1371" Count="0" />
      <LineId Id="1221" Count="19" />
      <LineId Id="1392" Count="0" />
      <LineId Id="1241" Count="4" />
      <LineId Id="1390" Count="1" />
      <LineId Id="1246" Count="5" />
      <LineId Id="1253" Count="1" />
      <LineId Id="1256" Count="0" />
      <LineId Id="1409" Count="0" />
      <LineId Id="1258" Count="1" />
      <LineId Id="1385" Count="1" />
      <LineId Id="1402" Count="0" />
      <LineId Id="1412" Count="0" />
      <LineId Id="1407" Count="0" />
      <LineId Id="1405" Count="0" />
      <LineId Id="1413" Count="1" />
      <LineId Id="163" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nCyclic">
      <LineId Id="186" Count="3" />
      <LineId Id="272" Count="0" />
      <LineId Id="190" Count="1" />
      <LineId Id="289" Count="0" />
      <LineId Id="192" Count="1" />
      <LineId Id="200" Count="5" />
      <LineId Id="214" Count="6" />
      <LineId Id="227" Count="10" />
      <LineId Id="321" Count="0" />
      <LineId Id="324" Count="1" />
      <LineId Id="238" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="239" Count="11" />
      <LineId Id="252" Count="9" />
      <LineId Id="297" Count="0" />
      <LineId Id="350" Count="0" />
      <LineId Id="299" Count="1" />
      <LineId Id="280" Count="0" />
      <LineId Id="336" Count="0" />
      <LineId Id="335" Count="0" />
      <LineId Id="310" Count="1" />
      <LineId Id="362" Count="0" />
      <LineId Id="338" Count="1" />
      <LineId Id="361" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="373" Count="0" />
      <LineId Id="288" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nDPSPowerOnOff">
      <LineId Id="6" Count="3" />
      <LineId Id="337" Count="0" />
      <LineId Id="343" Count="1" />
      <LineId Id="358" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="359" Count="1" />
      <LineId Id="342" Count="0" />
      <LineId Id="361" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="367" Count="8" />
      <LineId Id="279" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="40" Count="7" />
      <LineId Id="49" Count="1" />
      <LineId Id="57" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="322" Count="0" />
      <LineId Id="325" Count="4" />
      <LineId Id="61" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="293" Count="6" />
      <LineId Id="380" Count="0" />
      <LineId Id="300" Count="3" />
      <LineId Id="383" Count="0" />
      <LineId Id="304" Count="2" />
      <LineId Id="381" Count="0" />
      <LineId Id="307" Count="3" />
      <LineId Id="382" Count="0" />
      <LineId Id="311" Count="6" />
      <LineId Id="290" Count="0" />
      <LineId Id="289" Count="0" />
      <LineId Id="94" Count="1" />
      <LineId Id="163" Count="0" />
      <LineId Id="165" Count="10" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.M_nSystemReset">
      <LineId Id="9" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_ErrClear.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_ErrClear.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_sMessage.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_sMessage.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stParam.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stParam.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stVIO.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.P_stVIO.Set">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DebugStationSeq.PermSD">
      <LineId Id="2" Count="35" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>